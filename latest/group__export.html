<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cschannel: Exported symbols (public interface).</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cschannel&#160;<span id="projectnumber">latest</span></div>
   <div id="projectbrief">Streaming SChannel (SSL/TLS) wrapper.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__export.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Exported symbols (public interface).</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#gac423b95890081cb58a1c0a7697b769bc">security_package_setup</a> (struct <a class="el" href="structsecurity__package.html">security_package</a> *package)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain information about the security package.  <a href="#gac423b95890081cb58a1c0a7697b769bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#ga8223665ac323e8f11051746b6d0e9961">secure_channel_clear</a> (struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear channel state and set default settings.  <a href="#ga8223665ac323e8f11051746b6d0e9961"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#ga4404ea372a26fa196694da73598ac67e">secure_channel_setup</a> (const struct <a class="el" href="structsecurity__package.html">security_package</a> *package, struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel, enum secure_channel_role role)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish initialization and start negotiation.  <a href="#ga4404ea372a26fa196694da73598ac67e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#ga79e5a600ef6e2d7ece454bced344a928">secure_channel_push</a> (struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel, const char *data, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer message data for encryption (at a later time).  <a href="#ga79e5a600ef6e2d7ece454bced344a928"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#gaaa5f1890648adbb4398236c28f6098bc">secure_channel_pull</a> (struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel, const char *data, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to message decryption.  <a href="#gaaa5f1890648adbb4398236c28f6098bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#gac35a8b6a4649efd48b35fd32261e4270">secure_channel_flush</a> (struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Force any buffered data to be output.  <a href="#gac35a8b6a4649efd48b35fd32261e4270"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#ga7fae4c71a62d57e0a737ed7073d2255c">secure_channel_renegotiate</a> (struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify peer of intent to re-negotiate.  <a href="#ga7fae4c71a62d57e0a737ed7073d2255c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__export.html#ga89f33568a90886c68898fe3a226b6ef3">secure_channel_close</a> (struct <a class="el" href="structsecure__channel.html">secure_channel</a> *channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate shutdown.  <a href="#ga89f33568a90886c68898fe3a226b6ef3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>All symbols in this group are of public visibility and are intended for use by client code. All functions marked as such as considered stable and will not likely change in future versions of the library. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8223665ac323e8f11051746b6d0e9961"></a><!-- doxytag: member="cschannel.h::secure_channel_clear" ref="ga8223665ac323e8f11051746b6d0e9961" args="(struct secure_channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void secure_channel_clear </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear channel state and set default settings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Secure channel instance to clear.</td></tr>
  </table>
  </dd>
</dl>
<p>All modifications to default settings should be made after a call to this function is made.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__export.html#ga8223665ac323e8f11051746b6d0e9961" title="Clear channel state and set default settings.">secure_channel_clear()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Calls to this function after a call to <code><a class="el" href="group__export.html#ga4404ea372a26fa196694da73598ac67e" title="Finish initialization and start negotiation.">secure_channel_setup()</a></code> has been made results in undefined behavior. Common effects include memory leaks or large stream and token buffers. </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01253">1253</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga89f33568a90886c68898fe3a226b6ef3"></a><!-- doxytag: member="cschannel.h::secure_channel_close" ref="ga89f33568a90886c68898fe3a226b6ef3" args="(struct secure_channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void secure_channel_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate shutdown. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Secure channel instance to close.</td></tr>
  </table>
  </dd>
</dl>
<p>A call to this function produces a token that notifies the peer of the intent to shutdown the connection.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Figure out if the local channel can still decrypt data.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Unlike network sockets, the secure channel does not support unilateral shutdown. Moreover, the channel might need to re-negotiate at the peer's request, even if the application is only receiving data. Therefore, applications should be careful not to request a shutdown until all data is exchanged, and to keep the socket open even if a one-way socket shutdown is possible. </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01392">1392</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac35a8b6a4649efd48b35fd32261e4270"></a><!-- doxytag: member="cschannel.h::secure_channel_flush" ref="gac35a8b6a4649efd48b35fd32261e4270" args="(struct secure_channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void secure_channel_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force any buffered data to be output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Secure channel instance for which to encrypt buffered data.</td></tr>
  </table>
  </dd>
</dl>
<p>The secure channel allows the application to provide message parts in multiple calls to the <a class="el" href="group__export.html#gaaa5f1890648adbb4398236c28f6098bc" title="Attempt to message decryption.">secure_channel_pull()</a> function. Because of this, the secure channel requires a call to this function to actually encrypt data.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Depending on the security package limits (maximum message size) and channel configuration, it is possible that a message be encrypted without a call to this function. However, to ensure that data has been encrypted, this function a call! </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01377">1377</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa5f1890648adbb4398236c28f6098bc"></a><!-- doxytag: member="cschannel.h::secure_channel_pull" ref="gaaa5f1890648adbb4398236c28f6098bc" args="(struct secure_channel *channel, const char *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t secure_channel_pull </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to message decryption. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Security channel used for encryption. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to first byte of data to decrypt. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes, starting at <em>data</em>, to decrypt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes consumed by the channel, in [0, <em>size</em>].</dd></dl>
<p>Function used to process data received from the peer, before it is used by the application. All data to exchange over the secured connection must be passed to this filter.</p>
<p>This function <em>attempts</em> to decrypt received data. Because the secure channel is <em>message-based</em> and the transport mechanism is <em>stream-based</em>, it is possible to receive data in chunks smaller than the entire message. In such a case, data is buffered and kept until further data is provided and the message is completely received. Whenever data is decrypted, the resulting message data is passed back to the application using the <a class="el" href="group__callback.html#ga402206ac5fa7b66a4aa5e84825636a47" title="Callback invoked to notify of availabile decrypted data.">secure_channel::accept_decrypted</a> callback. </p>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01339">1339</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga79e5a600ef6e2d7ece454bced344a928"></a><!-- doxytag: member="cschannel.h::secure_channel_push" ref="ga79e5a600ef6e2d7ece454bced344a928" args="(struct secure_channel *channel, const char *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t secure_channel_push </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffer message data for encryption (at a later time). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Security channel used for encryption. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to first byte of data to encrypt. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes, starting at <em>data</em>, to encrypt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes consumed by the channel, in [0, <em>size</em>].</dd></dl>
<p>Function used to process data before it is sent to the peer. All data to exchange over the secured connection must be passed to this filter.</p>
<p>This function does not encrypt data. The application should invoke the <code>secure_channel_flush</code> method when a complete "message" is ready to be encrypted. Whenever data is encrypted, the resulting message data is passed back to the application using the <a class="el" href="group__callback.html#gadfdc80d25c128bcb7ac8060ef256c94a" title="Callback invoked to notify of availabile encrypted data.">secure_channel::accept_encrypted</a> callback.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__export.html#gac35a8b6a4649efd48b35fd32261e4270" title="Force any buffered data to be output.">secure_channel_flush()</a> </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01302">1302</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7fae4c71a62d57e0a737ed7073d2255c"></a><!-- doxytag: member="cschannel.h::secure_channel_renegotiate" ref="ga7fae4c71a62d57e0a737ed7073d2255c" args="(struct secure_channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void secure_channel_renegotiate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notify peer of intent to re-negotiate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Secure channel instance for which to request re-negotiation</td></tr>
  </table>
  </dd>
</dl>
<p>Re-negotiating the encryption keys is recommended after 1 Gigabyte or data has been exchanged, or 1 hour has elapsed since the last negotiation, whichever occurs first. However, re-negotiation is optional, and the request may be denied by the peer. Thus, the secure channel does not attempt to re-negotiate automatically and it is up to the application to request it if desired.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Re-negotiation of the connection is always optional. The peer may decide not to acknowledge the request. Also, the peer may continue to encrypt data until it ptocesses the renegotiation request. Because of these two limitations, the secure channel cannot determine if the peer ever processes the renegotiation request. </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01382">1382</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4404ea372a26fa196694da73598ac67e"></a><!-- doxytag: member="cschannel.h::secure_channel_setup" ref="ga4404ea372a26fa196694da73598ac67e" args="(const struct security_package *package, struct secure_channel *channel, enum secure_channel_role role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void secure_channel_setup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsecurity__package.html">security_package</a> *&#160;</td>
          <td class="paramname"><em>package</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsecure__channel.html">secure_channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum secure_channel_role&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish initialization and start negotiation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">package</td><td>Security package description. </td></tr>
    <tr><td class="paramname">channel</td><td>Security channel instance for which to start initialization. </td></tr>
    <tr><td class="paramname">role</td><td>Indicates whether the local host should initate negotiation or if the remote peer is expected to.</td></tr>
  </table>
  </dd>
</dl>
<p>For clients, this function produces the initial negotation token, which must be sent to the server for negotiation to continue. All modifications to default settings should be made before this call is invoked.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__export.html#ga8223665ac323e8f11051746b6d0e9961" title="Clear channel state and set default settings.">secure_channel_clear()</a> </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01274">1274</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac423b95890081cb58a1c0a7697b769bc"></a><!-- doxytag: member="cschannel.h::security_package_setup" ref="gac423b95890081cb58a1c0a7697b769bc" args="(struct security_package *package)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void security_package_setup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsecurity__package.html">security_package</a> *&#160;</td>
          <td class="paramname"><em>package</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain information about the security package. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">package</td><td>Security package description to fill in.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly used to request the maximum token size, in bytes. The specified limit is used to allocate token buffers on each side of the connection.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Call once and re-use for all channels. </dd></dl>

<p>Definition at line <a class="el" href="cschannel_8c_source.html#l01239">1239</a> of file <a class="el" href="cschannel_8c_source.html">cschannel.c</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Wed Aug 10 2011 23:20:36 for cschannel by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
