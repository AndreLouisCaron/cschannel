<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cschannel: code/cschannel.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cschannel&#160;<span id="projectnumber">latest</span></div>
   <div id="projectbrief">Streaming SChannel (SSL/TLS) wrapper.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('cschannel_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">code/cschannel.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright(c) Andre Caron, 2009-2011</span>
<a name="l00002"></a>00002 <span class="comment">**</span>
<a name="l00003"></a>00003 <span class="comment">** This document is covered by the an Open Source Initiative approved software</span>
<a name="l00004"></a>00004 <span class="comment">** license.  A copy of the license should have been provided alongside</span>
<a name="l00005"></a>00005 <span class="comment">** this software package (see &quot;license.txt&quot;).  If not, the license is available</span>
<a name="l00006"></a>00006 <span class="comment">** online at &quot;http://www.opensource.org/licenses/mit-license&quot;. */</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &quot;cschannel.h&quot;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00010"></a>00010 
<a name="l00094"></a>00094 <span class="comment">/*</span>
<a name="l00095"></a>00095 <span class="comment">** PROTOTYPES.</span>
<a name="l00096"></a>00096 <span class="comment">*/</span>
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__exchange.html#ga70b7387828f3a6e3f182dfab6320bac5" title="Attempt to decrypt message as chunk of stream.">secure_channel_decrypt</a>
<a name="l00099"></a>00099     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, PSecBufferDesc buffer );
<a name="l00100"></a>00100 <span class="keyword">static</span> <span class="keywordtype">void</span> prepare_dmbuffer ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel );
<a name="l00101"></a>00101 <span class="keyword">static</span> <span class="keywordtype">void</span> prepare_embuffer ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel );
<a name="l00102"></a>00102 <span class="keyword">static</span> <span class="keywordtype">void</span> reset_itoken_buffers ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel );
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keywordtype">void</span> reset_otoken_buffers ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel );
<a name="l00104"></a>00104 
<a name="l00110"></a><a class="code" href="group__internal.html#gafb880cf0a1b2f127bf32efeea9da4ebc">00110</a> <span class="keyword">static</span> SEC_WCHAR <a class="code" href="group__internal.html#gafb880cf0a1b2f127bf32efeea9da4ebc" title="Security package name.">PACKAGE_NAME</a>[] = SCHANNEL_NAME_W;
<a name="l00111"></a>00111 
<a name="l00117"></a><a class="code" href="group__internal.html#ga1b3066a2c3c3227c4679e76f1b91cd37">00117</a> <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="group__internal.html#ga1b3066a2c3c3227c4679e76f1b91cd37" title="Choose minimum of two buffer sizes.">channel_min</a> ( <span class="keywordtype">size_t</span> lhs, <span class="keywordtype">size_t</span> rhs )
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> (lhs &lt; rhs)? lhs : rhs;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">void</span> * poffset1 ( <span class="keywordtype">void</span> * data, <span class="keywordtype">size_t</span> size )
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124     <span class="keywordflow">return</span> (((<span class="keywordtype">char</span>*)data)+size);
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">void</span> * poffset2 ( <span class="keyword">const</span> <span class="keywordtype">void</span> * data, <span class="keywordtype">size_t</span> size )
<a name="l00128"></a>00128 {
<a name="l00129"></a>00129     <span class="keywordflow">return</span> (((<span class="keyword">const</span> <span class="keywordtype">char</span>*)data)+size);
<a name="l00130"></a>00130 }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="preprocessor">#if 0</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a> ( <span class="keywordtype">void</span> * ldata, <span class="keywordtype">size_t</span> loff, <span class="keywordtype">size_t</span> lsize,
<a name="l00134"></a>00134                              <span class="keyword">const</span> <span class="keywordtype">void</span> * rdata, <span class="keywordtype">size_t</span> rsize )
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136     <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = <a class="code" href="group__internal.html#ga1b3066a2c3c3227c4679e76f1b91cd37" title="Choose minimum of two buffer sizes.">channel_min</a>(lsize-loff, rsize-roff);
<a name="l00137"></a>00137     memcpy(poffset1(ldata,loff), poffset2(rdata,roff), size); 
<a name="l00138"></a>00138     <span class="keywordflow">return</span> (size);
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 <span class="preprocessor">#endif</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00147"></a><a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36">00147</a> <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a> ( PSecBuffer buffer, <span class="keywordtype">size_t</span> full,
<a name="l00148"></a>00148                                <span class="keyword">const</span> <span class="keywordtype">void</span> * data, <span class="keywordtype">size_t</span> size )
<a name="l00149"></a>00149 {
<a name="l00150"></a>00150       <span class="comment">/* fill to capacity. */</span>
<a name="l00151"></a>00151     <span class="keyword">const</span> <span class="keywordtype">size_t</span> used = <a class="code" href="group__internal.html#ga1b3066a2c3c3227c4679e76f1b91cd37" title="Choose minimum of two buffer sizes.">channel_min</a>(size, full-(buffer-&gt;cbBuffer));
<a name="l00152"></a>00152     memcpy(((<span class="keywordtype">char</span>*)buffer-&gt;pvBuffer)+(buffer-&gt;cbBuffer), data, used);
<a name="l00153"></a>00153       <span class="comment">/* update cursors. */</span>
<a name="l00154"></a>00154     buffer-&gt;cbBuffer += used;
<a name="l00155"></a>00155     <span class="keywordflow">return</span> (used);
<a name="l00156"></a>00156 }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="preprocessor">#if 0</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">size_t</span> channel_splice ( PSecBuffer lhs, PSecBuffer rhs, <span class="keywordtype">size_t</span> max_size )
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161       <span class="comment">/* fill to capacity. */</span>
<a name="l00162"></a>00162     <span class="keyword">const</span> <span class="keywordtype">size_t</span> used = <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(
<a name="l00163"></a>00163         lhs-&gt;pvBuffer, lhs-&gt;cbBuffer, rhs-&gt;pvBuffer, rhs-&gt;cbBuffer, max_size);
<a name="l00164"></a>00164     lhs-&gt;cbBuffer += used;
<a name="l00165"></a>00165     rhs-&gt;cbBuffer -= used;
<a name="l00166"></a>00166     <span class="keywordflow">return</span> (used);
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 <span class="preprocessor">#endif</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00175"></a>00175 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>
<a name="l00176"></a><a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c">00176</a>     ( <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00177"></a>00177 {
<a name="l00178"></a>00178     <span class="keyword">const</span> <span class="keywordtype">char</span> * role = <span class="stringliteral">&quot;?&quot;</span>;
<a name="l00179"></a>00179     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l00180"></a>00180         role = <span class="stringliteral">&quot;Client&quot;</span>;
<a name="l00181"></a>00181     }
<a name="l00182"></a>00182     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l00183"></a>00183         role = <span class="stringliteral">&quot;Server&quot;</span>;
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185     <span class="keywordflow">return</span> (role);
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00200"></a><a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425">00200</a> <span class="keyword">static</span> <span class="keywordtype">void</span> * <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keywordtype">size_t</span> size )
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202     <span class="keywordflow">return</span> ((channel-&gt;<a class="code" href="group__memory.html#gae6f1f7eb7014d5f4ceaba49ce2f1aece" title="Custom memory allocator&#39;s allocation function.">acquire_buffer</a> != 0)?
<a name="l00203"></a>00203         channel-&gt;<a class="code" href="group__memory.html#gae6f1f7eb7014d5f4ceaba49ce2f1aece" title="Custom memory allocator&#39;s allocation function.">acquire_buffer</a>(channel, size) : malloc(size));
<a name="l00204"></a>00204 }
<a name="l00205"></a>00205 
<a name="l00218"></a><a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab">00218</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keywordtype">void</span> * data )
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="group__memory.html#ga56e231135cf2c4d52f48a7fbb3cb7e55" title="Custom memory allocator&#39;s cleanup function.">release_buffer</a> == 0 ) {
<a name="l00221"></a>00221         free(data);
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223     <span class="keywordflow">else</span> {
<a name="l00224"></a>00224         channel-&gt;<a class="code" href="group__memory.html#ga56e231135cf2c4d52f48a7fbb3cb7e55" title="Custom memory allocator&#39;s cleanup function.">release_buffer</a>(channel, data);
<a name="l00225"></a>00225     }
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00238"></a><a class="code" href="group__memory.html#gabc4146d0d1a080e91bba5f589c4f060d">00238</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__memory.html#gabc4146d0d1a080e91bba5f589c4f060d" title="Acquire memory used for buffering security tokens.">acquire_token_buffers</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240     channel-&gt;itoken = <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a>(channel, channel-&gt;token_size);
<a name="l00241"></a>00241     channel-&gt;otoken = <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a>(channel, channel-&gt;token_size);
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 
<a name="l00252"></a><a class="code" href="group__memory.html#ga486431afd176183972a25dd0d9e332ed">00252</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__memory.html#ga486431afd176183972a25dd0d9e332ed" title="Release memory used for buffering security tokens.">release_token_buffers</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254     <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a>(channel, channel-&gt;itoken), channel-&gt;otoken=0;
<a name="l00255"></a>00255     <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a>(channel, channel-&gt;otoken), channel-&gt;otoken=0;
<a name="l00256"></a>00256     memset(channel-&gt;buffers+0, 0, 4*<span class="keyword">sizeof</span>(SecBuffer));
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00269"></a><a class="code" href="group__memory.html#gaa2a3609345abf308fe137fc4f1e19a47">00269</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__memory.html#gaa2a3609345abf308fe137fc4f1e19a47" title="Acquire memory used for buffering messages.">acquire_stream_buffers</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271     channel-&gt;emheader = <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a>(channel, channel-&gt;header_size);
<a name="l00272"></a>00272     channel-&gt;emstream = <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a>(channel, channel-&gt;stream_size);
<a name="l00273"></a>00273     channel-&gt;emfooter = <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a>(channel, channel-&gt;footer_size);
<a name="l00274"></a>00274     channel-&gt;dmstream = <a class="code" href="group__memory.html#gae49c24d7c7e4d586a3c0faeecb700425" title="Acquire memory used for buffering data.">channel_acquire</a>(channel, channel-&gt;stream_size);
<a name="l00275"></a>00275     prepare_embuffer(channel);
<a name="l00276"></a>00276     prepare_dmbuffer(channel);
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00287"></a><a class="code" href="group__memory.html#gae9db90aef9e5e79e91fe84ba83ede1ad">00287</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__memory.html#gae9db90aef9e5e79e91fe84ba83ede1ad" title="Release memory used for buffering messages.">release_stream_buffers</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00288"></a>00288 {
<a name="l00289"></a>00289     <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a>(channel, channel-&gt;emheader); channel-&gt;emheader=0;
<a name="l00290"></a>00290     <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a>(channel, channel-&gt;emstream); channel-&gt;emstream=0;
<a name="l00291"></a>00291     <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a>(channel, channel-&gt;emfooter); channel-&gt;emfooter=0;
<a name="l00292"></a>00292     <a class="code" href="group__memory.html#ga32e2e1bf1298257a5362c393d54a58ab" title="Release memory used for buffering data.">channel_release</a>(channel, channel-&gt;dmstream); channel-&gt;dmstream=0;
<a name="l00293"></a>00293     memset(channel-&gt;buffers+4, 0, 8*<span class="keyword">sizeof</span>(SecBuffer));
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00310"></a><a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6">00310</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312     <span class="comment">// 1st buffer contains in-bound token data.</span>
<a name="l00313"></a>00313     <span class="comment">// 2nd buffer contains ?</span>
<a name="l00314"></a>00314     channel-&gt;itbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l00315"></a>00315     channel-&gt;itbuffer.pBuffers = channel-&gt;buffers+0;
<a name="l00316"></a>00316     channel-&gt;itbuffer.cBuffers = 2;
<a name="l00317"></a>00317     channel-&gt;itbuffer.pBuffers[0].BufferType = SECBUFFER_TOKEN;
<a name="l00318"></a>00318     channel-&gt;itbuffer.pBuffers[0].cbBuffer   = 0;
<a name="l00319"></a>00319     channel-&gt;itbuffer.pBuffers[0].pvBuffer   = channel-&gt;itoken;
<a name="l00320"></a>00320     channel-&gt;itbuffer.pBuffers[1].BufferType = SECBUFFER_EMPTY;
<a name="l00321"></a>00321     channel-&gt;itbuffer.pBuffers[1].cbBuffer   = 0;
<a name="l00322"></a>00322     channel-&gt;itbuffer.pBuffers[1].pvBuffer   = 0;
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00342"></a><a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd">00342</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344     <span class="comment">// 1st buffer contains out-bound token data.</span>
<a name="l00345"></a>00345     <span class="comment">// 2nd buffer contains in-bound unused data (start of 1st message).</span>
<a name="l00346"></a>00346     channel-&gt;otbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l00347"></a>00347     channel-&gt;otbuffer.pBuffers = channel-&gt;buffers+2;
<a name="l00348"></a>00348     channel-&gt;otbuffer.cBuffers = 2;
<a name="l00349"></a>00349     channel-&gt;otbuffer.pBuffers[0].BufferType = SECBUFFER_TOKEN;
<a name="l00350"></a>00350     channel-&gt;otbuffer.pBuffers[0].cbBuffer   = channel-&gt;token_size;
<a name="l00351"></a>00351     channel-&gt;otbuffer.pBuffers[0].pvBuffer   = channel-&gt;otoken;
<a name="l00352"></a>00352     channel-&gt;otbuffer.pBuffers[1].BufferType = SECBUFFER_EMPTY;
<a name="l00353"></a>00353     channel-&gt;otbuffer.pBuffers[1].cbBuffer   = 0;
<a name="l00354"></a>00354     channel-&gt;otbuffer.pBuffers[1].pvBuffer   = 0;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00362"></a><a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8">00362</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8" title="Prepare buffers for production of control token.">prepare_ctbuffers</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364     <span class="comment">// if used, must be empty.</span>
<a name="l00365"></a>00365     channel-&gt;itbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l00366"></a>00366     channel-&gt;itbuffer.pBuffers = channel-&gt;buffers+0;
<a name="l00367"></a>00367     channel-&gt;itbuffer.cBuffers = 1;
<a name="l00368"></a>00368     channel-&gt;itbuffer.pBuffers[0].BufferType = SECBUFFER_EMPTY;
<a name="l00369"></a>00369     channel-&gt;itbuffer.pBuffers[0].cbBuffer   = 0;
<a name="l00370"></a>00370     channel-&gt;itbuffer.pBuffers[0].pvBuffer   = 0;
<a name="l00371"></a>00371     <span class="comment">// single buffer set to alert token.</span>
<a name="l00372"></a>00372     channel-&gt;otbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l00373"></a>00373     channel-&gt;otbuffer.pBuffers = channel-&gt;buffers+2;
<a name="l00374"></a>00374     channel-&gt;otbuffer.cBuffers = 1;
<a name="l00375"></a>00375     channel-&gt;otbuffer.pBuffers[0].BufferType = SECBUFFER_TOKEN;
<a name="l00376"></a>00376     channel-&gt;otbuffer.pBuffers[0].cbBuffer   = channel-&gt;token_size;
<a name="l00377"></a>00377     channel-&gt;otbuffer.pBuffers[0].pvBuffer   = channel-&gt;otoken;
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="keyword">static</span> <span class="keywordtype">void</span> prepare_dmbuffer ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00381"></a>00381 {
<a name="l00382"></a>00382     channel-&gt;dmbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l00383"></a>00383     channel-&gt;dmbuffer.pBuffers = channel-&gt;buffers+4;
<a name="l00384"></a>00384     channel-&gt;dmbuffer.cBuffers = 4;
<a name="l00385"></a>00385     channel-&gt;dmbuffer.pBuffers[0].BufferType = SECBUFFER_DATA;
<a name="l00386"></a>00386     channel-&gt;dmbuffer.pBuffers[0].cbBuffer   = 0;
<a name="l00387"></a>00387     channel-&gt;dmbuffer.pBuffers[0].pvBuffer   = channel-&gt;dmstream;
<a name="l00388"></a>00388     channel-&gt;dmbuffer.pBuffers[1].BufferType = SECBUFFER_EMPTY;
<a name="l00389"></a>00389     channel-&gt;dmbuffer.pBuffers[1].cbBuffer   = 0;
<a name="l00390"></a>00390     channel-&gt;dmbuffer.pBuffers[1].pvBuffer   = 0;
<a name="l00391"></a>00391     channel-&gt;dmbuffer.pBuffers[2].BufferType = SECBUFFER_EMPTY;
<a name="l00392"></a>00392     channel-&gt;dmbuffer.pBuffers[2].cbBuffer   = 0;
<a name="l00393"></a>00393     channel-&gt;dmbuffer.pBuffers[2].pvBuffer   = 0;
<a name="l00394"></a>00394     channel-&gt;dmbuffer.pBuffers[3].BufferType = SECBUFFER_EMPTY;
<a name="l00395"></a>00395     channel-&gt;dmbuffer.pBuffers[3].cbBuffer   = 0;
<a name="l00396"></a>00396     channel-&gt;dmbuffer.pBuffers[3].pvBuffer   = 0;
<a name="l00397"></a>00397 }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="keyword">static</span> <span class="keywordtype">void</span> prepare_embuffer ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00400"></a>00400 {
<a name="l00401"></a>00401     channel-&gt;embuffer.ulVersion = SECBUFFER_VERSION;
<a name="l00402"></a>00402     channel-&gt;embuffer.pBuffers = channel-&gt;buffers+8;
<a name="l00403"></a>00403     channel-&gt;embuffer.cBuffers = 4;
<a name="l00404"></a>00404     channel-&gt;embuffer.pBuffers[0].BufferType = SECBUFFER_STREAM_HEADER;
<a name="l00405"></a>00405     channel-&gt;embuffer.pBuffers[0].cbBuffer   = channel-&gt;header_size;
<a name="l00406"></a>00406     channel-&gt;embuffer.pBuffers[0].pvBuffer   = channel-&gt;emheader;
<a name="l00407"></a>00407     channel-&gt;embuffer.pBuffers[1].BufferType = SECBUFFER_DATA;
<a name="l00408"></a>00408     channel-&gt;embuffer.pBuffers[1].cbBuffer   = 0;
<a name="l00409"></a>00409     channel-&gt;embuffer.pBuffers[1].pvBuffer   = channel-&gt;emstream;
<a name="l00410"></a>00410     channel-&gt;embuffer.pBuffers[2].BufferType = SECBUFFER_STREAM_TRAILER;
<a name="l00411"></a>00411     channel-&gt;embuffer.pBuffers[2].cbBuffer   = channel-&gt;footer_size;
<a name="l00412"></a>00412     channel-&gt;embuffer.pBuffers[2].pvBuffer   = channel-&gt;emfooter;
<a name="l00413"></a>00413     channel-&gt;embuffer.pBuffers[3].BufferType = SECBUFFER_EMPTY;
<a name="l00414"></a>00414     channel-&gt;embuffer.pBuffers[3].cbBuffer   = 0;
<a name="l00415"></a>00415     channel-&gt;embuffer.pBuffers[3].pvBuffer   = 0;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00423"></a><a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23">00423</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425     ULONG i;
<a name="l00426"></a>00426     <span class="keywordflow">for</span> ( i = 0; (i &lt; channel-&gt;otbuffer.cBuffers); ++i )
<a name="l00427"></a>00427     {
<a name="l00428"></a>00428         PSecBuffer buffer = &amp;channel-&gt;otbuffer.pBuffers[i];
<a name="l00429"></a>00429         <span class="keywordflow">if</span> ( buffer-&gt;BufferType == SECBUFFER_TOKEN )
<a name="l00430"></a>00430         {
<a name="l00431"></a>00431               <span class="comment">/* forward data. */</span>
<a name="l00432"></a>00432             channel-&gt;<a class="code" href="group__callback.html#gadfdc80d25c128bcb7ac8060ef256c94a" title="Callback invoked to notify of availabile encrypted data.">accept_encrypted</a>(channel,
<a name="l00433"></a>00433                 buffer-&gt;pvBuffer, buffer-&gt;cbBuffer);
<a name="l00434"></a>00434               <span class="comment">/* expire token. */</span>
<a name="l00435"></a>00435             buffer-&gt;cbBuffer = 0;
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437         <span class="keywordflow">if</span> ( buffer-&gt;BufferType == SECBUFFER_EXTRA )
<a name="l00438"></a>00438         {
<a name="l00439"></a>00439               <span class="comment">/* forward data. */</span>
<a name="l00440"></a>00440             channel-&gt;<a class="code" href="group__callback.html#gaa4ef0c01606e7ce8e37c2e28d213d693" title="Callback invoked to notify of unused data in decryption.">accept_overflow</a>(channel,
<a name="l00441"></a>00441                 buffer-&gt;pvBuffer, buffer-&gt;cbBuffer);
<a name="l00442"></a>00442               <span class="comment">/* expire token. */</span>
<a name="l00443"></a>00443             buffer-&gt;cbBuffer = 0;
<a name="l00444"></a>00444         }
<a name="l00445"></a>00445     }
<a name="l00446"></a>00446 }
<a name="l00447"></a>00447 
<a name="l00460"></a><a class="code" href="group__callback.html#ga3e65f7631eba9fecdc5080336adf98bc">00460</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__callback.html#ga3e65f7631eba9fecdc5080336adf98bc" title="Forward leftover message parts using registered callbacks.">accept_overflow</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00461"></a>00461 {
<a name="l00462"></a>00462     ULONG i;
<a name="l00463"></a>00463     <span class="keywordflow">for</span> ( i = 0; (i &lt; channel-&gt;dmbuffer.cBuffers); ++i )
<a name="l00464"></a>00464     {
<a name="l00465"></a>00465         PSecBuffer buffer = &amp;channel-&gt;dmbuffer.pBuffers[i];
<a name="l00466"></a>00466         <span class="keywordflow">if</span> ( buffer-&gt;BufferType == SECBUFFER_EXTRA )
<a name="l00467"></a>00467         {
<a name="l00468"></a>00468               <span class="comment">/* forward data. */</span>
<a name="l00469"></a>00469             channel-&gt;<a class="code" href="group__callback.html#gaa4ef0c01606e7ce8e37c2e28d213d693" title="Callback invoked to notify of unused data in decryption.">accept_overflow</a>(channel,
<a name="l00470"></a>00470                 buffer-&gt;pvBuffer, buffer-&gt;cbBuffer);
<a name="l00471"></a>00471               <span class="comment">/* expire token. */</span>
<a name="l00472"></a>00472             buffer-&gt;cbBuffer = 0;
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00487"></a><a class="code" href="group__callback.html#gaac353f1a6bc455b8108f6a0ed0dfbe29">00487</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__callback.html#gaac353f1a6bc455b8108f6a0ed0dfbe29" title="Forward encrypted message content using registered callbacks.">accept_encrypted_message</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00488"></a>00488 {
<a name="l00489"></a>00489     ULONG i;
<a name="l00490"></a>00490       <span class="comment">/* forward encrypted data. */</span>
<a name="l00491"></a>00491     <span class="keywordflow">for</span> ( i = 0; (i &lt; channel-&gt;embuffer.cBuffers); ++i )
<a name="l00492"></a>00492     {
<a name="l00493"></a>00493         PSecBuffer buffer = &amp;channel-&gt;embuffer.pBuffers[i];
<a name="l00494"></a>00494         <span class="keywordflow">if</span> ( buffer-&gt;BufferType != SECBUFFER_EMPTY )
<a name="l00495"></a>00495         {
<a name="l00496"></a>00496             channel-&gt;<a class="code" href="group__callback.html#gadfdc80d25c128bcb7ac8060ef256c94a" title="Callback invoked to notify of availabile encrypted data.">accept_encrypted</a>(channel,
<a name="l00497"></a>00497                 buffer-&gt;pvBuffer, buffer-&gt;cbBuffer);
<a name="l00498"></a>00498             buffer-&gt;cbBuffer = 0;
<a name="l00499"></a>00499         }
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501       <span class="comment">/* prepare for next message. */</span>
<a name="l00502"></a>00502     prepare_embuffer(channel);
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00515"></a><a class="code" href="group__callback.html#ga643121c4a08ed7c10f5c9da527d4beda">00515</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__callback.html#ga643121c4a08ed7c10f5c9da527d4beda" title="Forward decrypted message content using registered callbacks.">accept_decrypted_message</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00516"></a>00516 {
<a name="l00517"></a>00517     ULONG i;
<a name="l00518"></a>00518     <span class="keywordtype">void</span> * extradata = 0;
<a name="l00519"></a>00519     <span class="keywordtype">size_t</span> extrasize = 0;
<a name="l00520"></a>00520       <span class="comment">/* forward decrypted data. */</span>
<a name="l00521"></a>00521     <span class="keywordflow">for</span> ( i = 0; (i &lt; channel-&gt;dmbuffer.cBuffers); ++i )
<a name="l00522"></a>00522     {
<a name="l00523"></a>00523         PSecBuffer buffer = &amp;channel-&gt;dmbuffer.pBuffers[i];
<a name="l00524"></a>00524         <span class="keywordflow">if</span> ( buffer-&gt;BufferType == SECBUFFER_DATA )
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526             channel-&gt;<a class="code" href="group__callback.html#ga402206ac5fa7b66a4aa5e84825636a47" title="Callback invoked to notify of availabile decrypted data.">accept_decrypted</a>(channel,
<a name="l00527"></a>00527                 buffer-&gt;pvBuffer, buffer-&gt;cbBuffer);
<a name="l00528"></a>00528             buffer-&gt;cbBuffer = 0;
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530         <span class="keywordflow">if</span> ( buffer-&gt;BufferType == SECBUFFER_EXTRA )
<a name="l00531"></a>00531         {
<a name="l00532"></a>00532             extrasize = buffer-&gt;cbBuffer;
<a name="l00533"></a>00533             extradata = buffer-&gt;pvBuffer;
<a name="l00534"></a>00534         }
<a name="l00535"></a>00535     }
<a name="l00536"></a>00536       <span class="comment">/* prepare for next message. */</span>
<a name="l00537"></a>00537     prepare_dmbuffer(channel);
<a name="l00538"></a>00538       <span class="comment">/* schedule use of leftovers. */</span>
<a name="l00539"></a>00539     <span class="keywordflow">if</span> ((extradata != 0) &amp;&amp; (extrasize &gt; 0))
<a name="l00540"></a>00540     {
<a name="l00541"></a>00541         <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;embuffer.pBuffers[0],
<a name="l00542"></a>00542             channel-&gt;stream_size, extradata, extrasize);
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 }
<a name="l00545"></a>00545 
<a name="l00551"></a><a class="code" href="group__server.html#ga9d8c7207a657f280fbc9c70d524be9b5">00551</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__server.html#ga9d8c7207a657f280fbc9c70d524be9b5" title="Acquire security credentials.">secure_channel_server_setup</a> (
<a name="l00552"></a>00552     <span class="keyword">struct</span> <a class="code" href="structsecurity__credentials.html" title="Information about the host&#39;s identity (local, self).">security_credentials</a> * credentials,
<a name="l00553"></a>00553     <span class="keyword">struct</span> <a class="code" href="structsecurity__certificate.html" title="Information about the host&#39;s identity (local, self).">security_certificate</a> * certificate )
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555     SECURITY_STATUS result;
<a name="l00556"></a>00556     
<a name="l00557"></a>00557       <span class="comment">/* describe expected behavior. */</span>
<a name="l00558"></a>00558     credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.dwVersion = SCHANNEL_CRED_VERSION;
<a name="l00559"></a>00559     credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.dwFlags =
<a name="l00560"></a>00560         SCH_CRED_NO_DEFAULT_CREDS |
<a name="l00561"></a>00561         SCH_CRED_NO_SYSTEM_MAPPER |
<a name="l00562"></a>00562         SCH_CRED_REVOCATION_CHECK_CHAIN;
<a name="l00563"></a>00563     credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.dwMinimumCipherStrength = 128;
<a name="l00564"></a>00564     
<a name="l00565"></a>00565       <span class="comment">/* server-side certificate is required. */</span>
<a name="l00566"></a>00566     <span class="keywordflow">if</span> ( certificate-&gt;<a class="code" href="structsecurity__certificate.html#a806f74539194fb426dd738e0aaabc4b3" title="Handle to opaque certificate state.">handle</a> &amp;&amp; (certificate-&gt;<a class="code" href="structsecurity__certificate.html#a806f74539194fb426dd738e0aaabc4b3" title="Handle to opaque certificate state.">handle</a> != 0)) {
<a name="l00567"></a>00567         credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.paCred = &amp;certificate-&gt;<a class="code" href="structsecurity__certificate.html#a806f74539194fb426dd738e0aaabc4b3" title="Handle to opaque certificate state.">handle</a>;
<a name="l00568"></a>00568         credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.cCreds = 1;
<a name="l00569"></a>00569     }
<a name="l00570"></a>00570     
<a name="l00571"></a>00571       <span class="comment">/* Acquire the handle. */</span>
<a name="l00572"></a>00572     result = AcquireCredentialsHandleW(
<a name="l00573"></a>00573         0, <a class="code" href="group__internal.html#gafb880cf0a1b2f127bf32efeea9da4ebc" title="Security package name.">PACKAGE_NAME</a>, SECPKG_CRED_INBOUND,
<a name="l00574"></a>00574         0, &amp;credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>, 0, 0,
<a name="l00575"></a>00575         &amp;credentials-&gt;<a class="code" href="structsecurity__credentials.html#a6daee4a3c167e6ffc08d64414dd3e78f" title="Handle to opaque credentials state.">handle</a>, 0
<a name="l00576"></a>00576         );
<a name="l00577"></a>00577     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00578"></a>00578     {
<a name="l00579"></a>00579         printf(<span class="stringliteral">&quot;Server: AcquireCredentialsHandle(): 0x%08x\n&quot;</span>, result);
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581 }
<a name="l00582"></a>00582 
<a name="l00588"></a><a class="code" href="group__client.html#gafe5e75b2c5433294bcf44d2bffa54341">00588</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#gafe5e75b2c5433294bcf44d2bffa54341" title="Acquire security credentials.">secure_channel_client_setup</a> (
<a name="l00589"></a>00589     <span class="keyword">struct</span> <a class="code" href="structsecurity__credentials.html" title="Information about the host&#39;s identity (local, self).">security_credentials</a> * credentials,
<a name="l00590"></a>00590     <span class="keyword">struct</span> <a class="code" href="structsecurity__certificate.html" title="Information about the host&#39;s identity (local, self).">security_certificate</a> * certificate )
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592     SECURITY_STATUS result;
<a name="l00593"></a>00593     
<a name="l00594"></a>00594       <span class="comment">/* describe expected behavior. */</span>
<a name="l00595"></a>00595     credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.dwVersion = SCHANNEL_CRED_VERSION;
<a name="l00596"></a>00596     credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.dwFlags =
<a name="l00597"></a>00597         SCH_CRED_NO_DEFAULT_CREDS |
<a name="l00598"></a>00598         SCH_CRED_NO_SYSTEM_MAPPER |
<a name="l00599"></a>00599         SCH_CRED_REVOCATION_CHECK_CHAIN;
<a name="l00600"></a>00600     credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.dwMinimumCipherStrength = 128;
<a name="l00601"></a>00601     
<a name="l00602"></a>00602       <span class="comment">/* client-side certificate is optional. */</span>
<a name="l00603"></a>00603     <span class="keywordflow">if</span> ( certificate &amp;&amp; (certificate-&gt;<a class="code" href="structsecurity__certificate.html#a806f74539194fb426dd738e0aaabc4b3" title="Handle to opaque certificate state.">handle</a> != 0) ) {
<a name="l00604"></a>00604         credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.paCred = &amp;certificate-&gt;<a class="code" href="structsecurity__certificate.html#a806f74539194fb426dd738e0aaabc4b3" title="Handle to opaque certificate state.">handle</a>;
<a name="l00605"></a>00605         credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>.cCreds = 1;
<a name="l00606"></a>00606     }
<a name="l00607"></a>00607     
<a name="l00608"></a>00608       <span class="comment">/* Acquire the handle. */</span>
<a name="l00609"></a>00609     result = AcquireCredentialsHandleW(
<a name="l00610"></a>00610         0, <a class="code" href="group__internal.html#gafb880cf0a1b2f127bf32efeea9da4ebc" title="Security package name.">PACKAGE_NAME</a>, SECPKG_CRED_OUTBOUND,
<a name="l00611"></a>00611         0, &amp;credentials-&gt;<a class="code" href="structsecurity__credentials.html#aec163f5991ef5f32874ca6dccd54a87e" title="Description of the identity exposed by the channel.">identity</a>, 0, 0,
<a name="l00612"></a>00612         &amp;credentials-&gt;<a class="code" href="structsecurity__credentials.html#a6daee4a3c167e6ffc08d64414dd3e78f" title="Handle to opaque credentials state.">handle</a>, 0
<a name="l00613"></a>00613         );
<a name="l00614"></a>00614     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00615"></a>00615     {
<a name="l00616"></a>00616         printf(<span class="stringliteral">&quot;Client: AcquireCredentialsHandle(): 0x%08x\n&quot;</span>, result);
<a name="l00617"></a>00617     }
<a name="l00618"></a>00618 }
<a name="l00619"></a>00619 
<a name="l00632"></a><a class="code" href="group__memory.html#gacd1f45ab25084c6c720271c72a0beb7a">00632</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__memory.html#gacd1f45ab25084c6c720271c72a0beb7a" title="Request channel limits from security package.">secure_channel_fetch_sizes</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00633"></a>00633 {
<a name="l00634"></a>00634     SECURITY_STATUS result;
<a name="l00635"></a>00635     SecPkgContext_StreamSizes sizes;
<a name="l00636"></a>00636       <span class="comment">/* fetch minimal buffer sizes. */</span>
<a name="l00637"></a>00637     result = QueryContextAttributes
<a name="l00638"></a>00638         (&amp;channel-&gt;handle, SECPKG_ATTR_STREAM_SIZES, &amp;sizes);
<a name="l00639"></a>00639     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00640"></a>00640     {
<a name="l00641"></a>00641         printf(<span class="stringliteral">&quot;%s: QueryContextAttributes(): 0x%08x\n&quot;</span>,
<a name="l00642"></a>00642             <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644       <span class="comment">/* copy interesting fields. */</span>
<a name="l00645"></a>00645     channel-&gt;header_size = sizes.cbHeader;
<a name="l00646"></a>00646     channel-&gt;stream_size = sizes.cbMaximumMessage;
<a name="l00647"></a>00647     channel-&gt;footer_size = sizes.cbTrailer;
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00655"></a>00655 <span class="keyword">static</span> SECURITY_STATUS <a class="code" href="group__control.html#gaa7c46ce7b0f5eb39001b9b53bf9a46c6" title="Apply some control information to the secure channel state.">channel_apply</a>
<a name="l00656"></a><a class="code" href="group__control.html#gaa7c46ce7b0f5eb39001b9b53bf9a46c6">00656</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keywordtype">void</span> * data, DWORD size )
<a name="l00657"></a>00657 {
<a name="l00658"></a>00658     SECURITY_STATUS result;
<a name="l00659"></a>00659     SecBuffer token;
<a name="l00660"></a>00660     SecBufferDesc buffer;
<a name="l00661"></a>00661     token.BufferType = SECBUFFER_TOKEN;<span class="comment">//SECBUFFER_PKG_PARAMS;</span>
<a name="l00662"></a>00662     token.cbBuffer = size;
<a name="l00663"></a>00663     token.pvBuffer = data;
<a name="l00664"></a>00664     buffer.ulVersion = SECBUFFER_VERSION;
<a name="l00665"></a>00665     buffer.cBuffers = 1;
<a name="l00666"></a>00666     buffer.pBuffers = &amp;token;
<a name="l00667"></a>00667       <span class="comment">/* apply token buffer. */</span>
<a name="l00668"></a>00668     result = ApplyControlToken(&amp;channel-&gt;handle, &amp;buffer);
<a name="l00669"></a>00669     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00670"></a>00670     {
<a name="l00671"></a>00671         printf(<span class="stringliteral">&quot;%s: ApplyControlToken(): 0x%08x\n&quot;</span>,
<a name="l00672"></a>00672             <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l00673"></a>00673         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l00674"></a>00674         channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l00675"></a>00675     }
<a name="l00676"></a>00676     <span class="keywordflow">return</span> (result);
<a name="l00677"></a>00677 }
<a name="l00678"></a>00678 
<a name="l00684"></a><a class="code" href="group__control.html#gac15c22e7f4ceb7e44f434543afc0765b">00684</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__control.html#gac15c22e7f4ceb7e44f434543afc0765b" title="Notify peer of request to renegotiate.">channel_reconnect_status</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00685"></a>00685 {
<a name="l00686"></a>00686     SECURITY_STATUS result;
<a name="l00687"></a>00687     SCHANNEL_SESSION_TOKEN token;
<a name="l00688"></a>00688       <span class="comment">/* setup token. */</span>
<a name="l00689"></a>00689     token.dwTokenType = SCHANNEL_SESSION;
<a name="l00690"></a>00690     token.dwFlags = channel-&gt;<a class="code" href="structsecure__channel.html#ad19ab3d159ca487c345d0a3d267bb035" title="Set to 0 to disable quick reconnect.">allow_reconnect</a>?
<a name="l00691"></a>00691         SSL_SESSION_ENABLE_RECONNECTS : SSL_SESSION_DISABLE_RECONNECTS;
<a name="l00692"></a>00692       <span class="comment">/* apply token. */</span>
<a name="l00693"></a>00693     result = <a class="code" href="group__control.html#gaa7c46ce7b0f5eb39001b9b53bf9a46c6" title="Apply some control information to the secure channel state.">channel_apply</a>(channel, &amp;token, <span class="keyword">sizeof</span>(token));
<a name="l00694"></a>00694 }
<a name="l00695"></a>00695 
<a name="l00701"></a>00701 <span class="keyword">static</span> SECURITY_STATUS <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>
<a name="l00702"></a><a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a">00702</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, PCredHandle lhs, PCredHandle rhs,
<a name="l00703"></a>00703     PSecBufferDesc put, PSecBufferDesc <span class="keyword">get</span>, SEC_WCHAR * target )
<a name="l00704"></a>00704 {
<a name="l00705"></a>00705     SECURITY_STATUS result;
<a name="l00706"></a>00706     DWORD query;
<a name="l00707"></a>00707     DWORD reply;
<a name="l00708"></a>00708       <span class="comment">/* flags. */</span>
<a name="l00709"></a>00709     query =
<a name="l00710"></a>00710         <span class="comment">//ISC_REQ_ALLOCATE_MEMORY   |</span>
<a name="l00711"></a>00711         ISC_REQ_SEQUENCE_DETECT   |
<a name="l00712"></a>00712         ISC_REQ_REPLAY_DETECT     |
<a name="l00713"></a>00713         ISC_REQ_CONFIDENTIALITY   |
<a name="l00714"></a>00714         ISC_RET_EXTENDED_ERROR    |
<a name="l00715"></a>00715         ISC_REQ_STREAM            |
<a name="l00716"></a>00716         ISC_REQ_MANUAL_CRED_VALIDATION;
<a name="l00717"></a>00717       <span class="comment">/* negotiate. */</span>
<a name="l00718"></a>00718     result = InitializeSecurityContextW(
<a name="l00719"></a>00719         &amp;channel-&gt;<a class="code" href="structsecure__channel.html#ad879e1837e04ff5be64ce62df7254019" title="Host credentials (local peer, self).">credentials</a>.<a class="code" href="structsecurity__credentials.html#a6daee4a3c167e6ffc08d64414dd3e78f" title="Handle to opaque credentials state.">handle</a>, lhs, target,
<a name="l00720"></a>00720         query, 0, 0, put, 0, rhs, <span class="keyword">get</span>, &amp;reply, 0);
<a name="l00721"></a>00721       <span class="comment">/* */</span>
<a name="l00722"></a>00722     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00723"></a>00723     {
<a name="l00724"></a>00724         <span class="keywordflow">if</span> ( result == SEC_E_INCOMPLETE_MESSAGE )
<a name="l00725"></a>00725         {
<a name="l00726"></a>00726             channel-&gt;<a class="code" href="structsecure__channel.html#a2d957ce9060f92b139708b991880e2fe" title="Set to 1 when the stream expects a secure_channel_push() call.">need_push</a> = 1;
<a name="l00727"></a>00727             channel-&gt;<a class="code" href="structsecure__channel.html#a3cfe83cb5e19209ccde6aa02dbab2127" title="Set to 1 when the stream expects a secure_channel_pull() call.">need_pull</a> = 0;
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729         <span class="keywordflow">if</span> ( result == SEC_I_RENEGOTIATE )
<a name="l00730"></a>00730         {
<a name="l00731"></a>00731             <span class="keywordflow">return</span> (result);
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733         <span class="keywordflow">if</span> ( result != SEC_E_INCOMPLETE_MESSAGE )
<a name="l00734"></a>00734         {
<a name="l00735"></a>00735             printf(<span class="stringliteral">&quot;%s: InitializeSecurityContext(): 0x%08x\n&quot;</span>,
<a name="l00736"></a>00736                 <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l00737"></a>00737         }
<a name="l00738"></a>00738     }
<a name="l00739"></a>00739       <span class="comment">/* */</span>
<a name="l00740"></a>00740     <span class="keywordflow">if</span> ((result == SEC_I_COMPLETE_NEEDED) ||
<a name="l00741"></a>00741         (result == SEC_I_COMPLETE_AND_CONTINUE))
<a name="l00742"></a>00742     {
<a name="l00743"></a>00743         result = CompleteAuthToken(&amp;channel-&gt;handle, &amp;channel-&gt;embuffer);
<a name="l00744"></a>00744         <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00745"></a>00745         {
<a name="l00746"></a>00746             printf(<span class="stringliteral">&quot;%s: CompleteAuthToken(): 0x%08x\n&quot;</span>,
<a name="l00747"></a>00747                 <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750     <span class="keywordflow">return</span> (result);
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00758"></a><a class="code" href="group__client.html#ga7aadb401915beb6f89f52a67c5de8b62">00758</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#ga7aadb401915beb6f89f52a67c5de8b62" title="Produce initial negotiation token (&quot;ClientHello&quot;).">secure_channel_client_token_1</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760     SECURITY_STATUS result;
<a name="l00761"></a>00761     <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a>(channel);
<a name="l00762"></a>00762     result = <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>(channel,
<a name="l00763"></a>00763         0, &amp;channel-&gt;handle, 0, &amp;channel-&gt;otbuffer, 0);
<a name="l00764"></a>00764       <span class="comment">/* negotiation in progress. */</span>
<a name="l00765"></a>00765     <span class="keywordflow">if</span> ( result == SEC_I_CONTINUE_NEEDED )
<a name="l00766"></a>00766     {
<a name="l00767"></a>00767         printf(<span class="stringliteral">&quot;Client: obtained context handle.\n&quot;</span>);
<a name="l00768"></a>00768         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00769"></a>00769         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l00770"></a>00770         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_unsafe;
<a name="l00771"></a>00771     }
<a name="l00772"></a>00772 }
<a name="l00773"></a>00773 
<a name="l00779"></a><a class="code" href="group__client.html#ga3193bc64f5319fd4904dbe88790f4258">00779</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#ga3193bc64f5319fd4904dbe88790f4258" title="Produce additional negotiation tokens.">secure_channel_client_token_2</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781     SECURITY_STATUS result;
<a name="l00782"></a>00782     <span class="keywordflow">if</span> ( channel-&gt;itbuffer.pBuffers[0].cbBuffer &lt;= 0 ) {
<a name="l00783"></a>00783         <span class="keywordflow">return</span>;
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785     <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a>(channel);
<a name="l00786"></a>00786     result = <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>(channel,
<a name="l00787"></a>00787         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer, 0);
<a name="l00788"></a>00788       <span class="comment">/* server requested client certificate and we didn&#39;t send one. */</span>
<a name="l00789"></a>00789     <span class="keywordflow">if</span> ( result == SEC_I_INCOMPLETE_CREDENTIALS )
<a name="l00790"></a>00790     {
<a name="l00791"></a>00791         printf(<span class="stringliteral">&quot;Client: credentials required!\n&quot;</span>);
<a name="l00792"></a>00792         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l00793"></a>00793         channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795       <span class="comment">/* token produced */</span>
<a name="l00796"></a>00796     <span class="keywordflow">if</span> ( result == SEC_I_CONTINUE_NEEDED )
<a name="l00797"></a>00797     {
<a name="l00798"></a>00798         printf(<span class="stringliteral">&quot;Client: continue negotiation.\n&quot;</span>);
<a name="l00799"></a>00799         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00800"></a>00800         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802       <span class="comment">/* token produced, negotiation complete */</span>
<a name="l00803"></a>00803     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l00804"></a>00804     {
<a name="l00805"></a>00805         printf(<span class="stringliteral">&quot;Client: negotiation complete!\n&quot;</span>);
<a name="l00806"></a>00806         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00807"></a>00807         <a class="code" href="group__memory.html#gacd1f45ab25084c6c720271c72a0beb7a" title="Request channel limits from security package.">secure_channel_fetch_sizes</a>(channel);
<a name="l00808"></a>00808         <a class="code" href="group__memory.html#gaa2a3609345abf308fe137fc4f1e19a47" title="Acquire memory used for buffering messages.">acquire_stream_buffers</a>(channel);
<a name="l00809"></a>00809         <span class="comment">//release_token_buffers(channel);</span>
<a name="l00810"></a>00810         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_secure;
<a name="l00811"></a>00811         <span class="comment">//channel_reconnect_status(channel);</span>
<a name="l00812"></a>00812         channel-&gt;requested_renegotiation = 0;
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00820"></a><a class="code" href="group__client.html#ga0c4c58fa2becde4119eec419baf01e97">00820</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#ga0c4c58fa2becde4119eec419baf01e97" title="Produce re-negotiation REQUEST token.">secure_channel_client_token_0</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00821"></a>00821 {
<a name="l00822"></a>00822     SECURITY_STATUS result;
<a name="l00823"></a>00823     <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a>(channel);
<a name="l00824"></a>00824     result = <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>(channel,
<a name="l00825"></a>00825         &amp;channel-&gt;handle, 0, 0, &amp;channel-&gt;otbuffer, 0);
<a name="l00826"></a>00826       <span class="comment">/* token produced */</span>
<a name="l00827"></a>00827     <span class="keywordflow">if</span> ( result == SEC_I_CONTINUE_NEEDED )
<a name="l00828"></a>00828     {
<a name="l00829"></a>00829         printf(<span class="stringliteral">&quot;Client: re-negotiation requested.\n&quot;</span>);
<a name="l00830"></a>00830         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00831"></a>00831         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l00832"></a>00832         channel-&gt;requested_renegotiation = 1;
<a name="l00833"></a>00833     }
<a name="l00834"></a>00834 }
<a name="l00835"></a>00835 
<a name="l00840"></a><a class="code" href="group__client.html#ga69dbfe48bf1dddbefe8ea51609a00ee1">00840</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#ga69dbfe48bf1dddbefe8ea51609a00ee1" title="Produce re-negotiation token (different from REQUEST token).">secure_channel_client_token_4</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00841"></a>00841 {
<a name="l00842"></a>00842     SECURITY_STATUS result;
<a name="l00843"></a>00843     <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a>(channel);
<a name="l00844"></a>00844     result = <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>(channel,
<a name="l00845"></a>00845         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer, 0);
<a name="l00846"></a>00846       <span class="comment">/* token produced. */</span>
<a name="l00847"></a>00847     <span class="keywordflow">if</span> ( result == SEC_I_CONTINUE_NEEDED )
<a name="l00848"></a>00848     {
<a name="l00849"></a>00849         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00850"></a>00850         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l00851"></a>00851         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_unsafe;
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 
<a name="l00860"></a><a class="code" href="group__client.html#ga706a57e2c1a2539b25ef2057659d5262">00860</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#ga706a57e2c1a2539b25ef2057659d5262" title="Produce alert token.">secure_channel_client_token_5</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00861"></a>00861 {
<a name="l00862"></a>00862     SECURITY_STATUS result;
<a name="l00863"></a>00863     <a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8" title="Prepare buffers for production of control token.">prepare_ctbuffers</a>(channel);
<a name="l00864"></a>00864     result = <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>(channel,
<a name="l00865"></a>00865         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer, 0);
<a name="l00866"></a>00866       <span class="comment">/* token produced. */</span>
<a name="l00867"></a>00867     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l00868"></a>00868     {
<a name="l00869"></a>00869         printf(<span class="stringliteral">&quot;Client: alert token produced.\n&quot;</span>);
<a name="l00870"></a>00870         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872 }
<a name="l00873"></a>00873 
<a name="l00879"></a><a class="code" href="group__client.html#ga736e518421cdb1aedcccf2eef101924e">00879</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__client.html#ga736e518421cdb1aedcccf2eef101924e" title="Produce shutdown notification token.">secure_channel_client_token_3</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00880"></a>00880 {
<a name="l00881"></a>00881     SECURITY_STATUS result;
<a name="l00882"></a>00882     <a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8" title="Prepare buffers for production of control token.">prepare_ctbuffers</a>(channel);
<a name="l00883"></a>00883     result = <a class="code" href="group__client.html#gac0f7f95eea5860ffbf7a4725522a8d2a" title="Auxiliary, low-level, negotiation function.">secure_channel_client_token</a>(channel,
<a name="l00884"></a>00884         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer, 0);
<a name="l00885"></a>00885       <span class="comment">/* token produced */</span>
<a name="l00886"></a>00886     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l00887"></a>00887     {
<a name="l00888"></a>00888         printf(<span class="stringliteral">&quot;Client: shutdown has begun.\n&quot;</span>);
<a name="l00889"></a>00889         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00890"></a>00890         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_expire;
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00899"></a>00899 <span class="keyword">static</span> SECURITY_STATUS <a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9" title="Auxiliary, low-level, negotiation function.">secure_channel_server_token</a>
<a name="l00900"></a><a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9">00900</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, PCredHandle lhs, PCredHandle rhs,
<a name="l00901"></a>00901     PSecBufferDesc put, PSecBufferDesc <span class="keyword">get</span> )
<a name="l00902"></a>00902 {
<a name="l00903"></a>00903     SECURITY_STATUS result;
<a name="l00904"></a>00904     DWORD query;
<a name="l00905"></a>00905     DWORD reply;
<a name="l00906"></a>00906       <span class="comment">/* */</span>
<a name="l00907"></a>00907     query =
<a name="l00908"></a>00908         <span class="comment">//ASC_REQ_ALLOCATE_MEMORY   |</span>
<a name="l00909"></a>00909         ASC_REQ_SEQUENCE_DETECT   |
<a name="l00910"></a>00910         ASC_REQ_REPLAY_DETECT     |
<a name="l00911"></a>00911         ASC_REQ_CONFIDENTIALITY   |
<a name="l00912"></a>00912         ASC_RET_EXTENDED_ERROR    |
<a name="l00913"></a>00913         ASC_REQ_STREAM;
<a name="l00914"></a>00914     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="group__server.html#gad04e94f154f0e5c5400ef2373b296d09" title="Set to 1 to request client certificate, 0 by default.">mutual_authentication</a> ) {
<a name="l00915"></a>00915         query |= ASC_REQ_MUTUAL_AUTH;
<a name="l00916"></a>00916     }
<a name="l00917"></a>00917       <span class="comment">/* */</span>
<a name="l00918"></a>00918     result = AcceptSecurityContext(
<a name="l00919"></a>00919         &amp;channel-&gt;<a class="code" href="structsecure__channel.html#ad879e1837e04ff5be64ce62df7254019" title="Host credentials (local peer, self).">credentials</a>.<a class="code" href="structsecurity__credentials.html#a6daee4a3c167e6ffc08d64414dd3e78f" title="Handle to opaque credentials state.">handle</a>, lhs, put, query, 0, rhs, <span class="keyword">get</span>, &amp;reply, 0);
<a name="l00920"></a>00920       <span class="comment">/* */</span>
<a name="l00921"></a>00921     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00922"></a>00922     {
<a name="l00923"></a>00923         <span class="keywordflow">if</span> ( result == SEC_E_INCOMPLETE_MESSAGE )
<a name="l00924"></a>00924         {
<a name="l00925"></a>00925             channel-&gt;<a class="code" href="structsecure__channel.html#a2d957ce9060f92b139708b991880e2fe" title="Set to 1 when the stream expects a secure_channel_push() call.">need_push</a> = 1;
<a name="l00926"></a>00926             channel-&gt;<a class="code" href="structsecure__channel.html#a3cfe83cb5e19209ccde6aa02dbab2127" title="Set to 1 when the stream expects a secure_channel_pull() call.">need_pull</a> = 0;
<a name="l00927"></a>00927         }
<a name="l00928"></a>00928         <span class="keywordflow">if</span> ( result != SEC_E_INCOMPLETE_MESSAGE )
<a name="l00929"></a>00929         {
<a name="l00930"></a>00930             printf(<span class="stringliteral">&quot;%s: AcceptSecurityContext(): 0x%08x\n&quot;</span>,
<a name="l00931"></a>00931                 <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l00932"></a>00932             channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l00933"></a>00933             channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l00934"></a>00934         }
<a name="l00935"></a>00935     }
<a name="l00936"></a>00936       <span class="comment">/* */</span>
<a name="l00937"></a>00937     <span class="keywordflow">if</span> ((result == SEC_I_COMPLETE_NEEDED) ||
<a name="l00938"></a>00938         (result == SEC_I_COMPLETE_AND_CONTINUE))
<a name="l00939"></a>00939     {
<a name="l00940"></a>00940         result = CompleteAuthToken(rhs, <span class="keyword">get</span>);
<a name="l00941"></a>00941         <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l00942"></a>00942         {
<a name="l00943"></a>00943             printf(<span class="stringliteral">&quot;%s: CompleteAuthToken(): 0x%08x\n&quot;</span>,
<a name="l00944"></a>00944                 <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l00945"></a>00945             channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l00946"></a>00946             channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949     <span class="keywordflow">return</span> (result);
<a name="l00950"></a>00950 }
<a name="l00951"></a>00951 
<a name="l00957"></a><a class="code" href="group__server.html#gacbe602261078b49b52d126233f5acf39">00957</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__server.html#gacbe602261078b49b52d126233f5acf39" title="Produce initial neogitation token (&quot;ServerHello&quot;).">secure_channel_server_token_1</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00958"></a>00958 {
<a name="l00959"></a>00959     SECURITY_STATUS result;
<a name="l00960"></a>00960     <span class="keywordflow">if</span> ( channel-&gt;itbuffer.pBuffers[0].cbBuffer &lt;= 0 ) {
<a name="l00961"></a>00961         <span class="keywordflow">return</span>;
<a name="l00962"></a>00962     }
<a name="l00963"></a>00963     <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a>(channel);
<a name="l00964"></a>00964     result = <a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9" title="Auxiliary, low-level, negotiation function.">secure_channel_server_token</a>(channel,
<a name="l00965"></a>00965         0, &amp;channel-&gt;handle, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer);
<a name="l00966"></a>00966       <span class="comment">/* token produced, continue negotiation. */</span>
<a name="l00967"></a>00967     <span class="keywordflow">if</span> ( result == SEC_I_CONTINUE_NEEDED )
<a name="l00968"></a>00968     {
<a name="l00969"></a>00969         printf(<span class="stringliteral">&quot;Server: obtained context handle.\n&quot;</span>);
<a name="l00970"></a>00970         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00971"></a>00971         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l00972"></a>00972         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_unsafe;
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 
<a name="l00981"></a><a class="code" href="group__server.html#ga790f7a1074d2fadfdcff8d3ea988e51e">00981</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__server.html#ga790f7a1074d2fadfdcff8d3ea988e51e" title="Produce additional neogitation tokens.">secure_channel_server_token_2</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l00982"></a>00982 {
<a name="l00983"></a>00983     SECURITY_STATUS result;
<a name="l00984"></a>00984     <span class="keywordflow">if</span> ( channel-&gt;itbuffer.pBuffers[0].cbBuffer &lt;= 0 ) {
<a name="l00985"></a>00985         <span class="keywordflow">return</span>;
<a name="l00986"></a>00986     }
<a name="l00987"></a>00987     <a class="code" href="group__buffers.html#ga2e14ab9cb98ad57f45a58cf9f546d3cd" title="Prepare put buffer for reception of negotiation token.">prepare_otbuffer</a>(channel);
<a name="l00988"></a>00988     result = <a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9" title="Auxiliary, low-level, negotiation function.">secure_channel_server_token</a>(channel,
<a name="l00989"></a>00989         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer);
<a name="l00990"></a>00990       <span class="comment">/* token produced, continue negotiation. */</span>
<a name="l00991"></a>00991     <span class="keywordflow">if</span> ( result == SEC_I_CONTINUE_NEEDED )
<a name="l00992"></a>00992     {
<a name="l00993"></a>00993         printf(<span class="stringliteral">&quot;Server: continue negotiation.\n&quot;</span>);
<a name="l00994"></a>00994         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l00995"></a>00995         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l00996"></a>00996     }
<a name="l00997"></a>00997       <span class="comment">/* negotiation complete. */</span>
<a name="l00998"></a>00998     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000         printf(<span class="stringliteral">&quot;Server: negotiation complete!\n&quot;</span>);
<a name="l01001"></a>01001         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l01002"></a>01002         <a class="code" href="group__memory.html#gacd1f45ab25084c6c720271c72a0beb7a" title="Request channel limits from security package.">secure_channel_fetch_sizes</a>(channel);
<a name="l01003"></a>01003         <a class="code" href="group__memory.html#gaa2a3609345abf308fe137fc4f1e19a47" title="Acquire memory used for buffering messages.">acquire_stream_buffers</a>(channel);
<a name="l01004"></a>01004         <span class="comment">//release_token_buffers(channel);</span>
<a name="l01005"></a>01005         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_secure;
<a name="l01006"></a>01006         <span class="comment">//channel_reconnect_status(channel);</span>
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008       <span class="comment">/* peer rejected renegotiation request. */</span>
<a name="l01009"></a>01009     <span class="keywordflow">if</span> ( result == SEC_I_NO_RENEGOTIATION )
<a name="l01010"></a>01010     {
<a name="l01011"></a>01011         printf(<span class="stringliteral">&quot;Server: re-negotiation rejected!\n&quot;</span>);
<a name="l01012"></a>01012         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l01013"></a>01013         channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l01014"></a>01014     }
<a name="l01015"></a>01015 }
<a name="l01016"></a>01016 
<a name="l01022"></a><a class="code" href="group__server.html#ga20d1d34ccf686a76514fc8c881838771">01022</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__server.html#ga20d1d34ccf686a76514fc8c881838771" title="Produce re-negotiation request token.">secure_channel_server_token_0</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01023"></a>01023 {
<a name="l01024"></a>01024     SECURITY_STATUS result;
<a name="l01025"></a>01025     <a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8" title="Prepare buffers for production of control token.">prepare_ctbuffers</a>(channel);
<a name="l01026"></a>01026     result = <a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9" title="Auxiliary, low-level, negotiation function.">secure_channel_server_token</a>(channel,
<a name="l01027"></a>01027         &amp;channel-&gt;handle, 0, 0, &amp;channel-&gt;otbuffer);
<a name="l01028"></a>01028       <span class="comment">/* token produced, expect token in return. */</span>
<a name="l01029"></a>01029     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031         printf(<span class="stringliteral">&quot;Server: requested re-negotiation.\n&quot;</span>);
<a name="l01032"></a>01032         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l01033"></a>01033         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l01034"></a>01034         <span class="comment">/* NOTE: the client may have already encrypted one or messages, so the</span>
<a name="l01035"></a>01035 <span class="comment">             channel must keep decrypting data until the peer actually responds</span>
<a name="l01036"></a>01036 <span class="comment">             to the re-negotiation request. */</span>
<a name="l01037"></a>01037     }
<a name="l01038"></a>01038 }
<a name="l01039"></a>01039 
<a name="l01045"></a><a class="code" href="group__server.html#ga920a577bb040e1df2fe15fa4a120e980">01045</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__server.html#ga920a577bb040e1df2fe15fa4a120e980" title="Produce shutdown notification token.">secure_channel_server_token_3</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01046"></a>01046 {
<a name="l01047"></a>01047     SECURITY_STATUS result;
<a name="l01048"></a>01048     <a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8" title="Prepare buffers for production of control token.">prepare_ctbuffers</a>(channel);
<a name="l01049"></a>01049     result = <a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9" title="Auxiliary, low-level, negotiation function.">secure_channel_server_token</a>(channel,
<a name="l01050"></a>01050         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer);
<a name="l01051"></a>01051       <span class="comment">/* token produced. */</span>
<a name="l01052"></a>01052     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l01053"></a>01053     {
<a name="l01054"></a>01054         printf(<span class="stringliteral">&quot;Server: shutdown initiated.\n&quot;</span>);
<a name="l01055"></a>01055         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l01056"></a>01056         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_expire;
<a name="l01057"></a>01057     }
<a name="l01058"></a>01058 }
<a name="l01059"></a>01059 
<a name="l01065"></a><a class="code" href="group__server.html#ga20f74f12e34d72d158efa16a408d2a55">01065</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__server.html#ga20f74f12e34d72d158efa16a408d2a55" title="Produce alert token.">secure_channel_server_token_5</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01066"></a>01066 {
<a name="l01067"></a>01067     SECURITY_STATUS result;
<a name="l01068"></a>01068     <a class="code" href="group__buffers.html#ga55f67c3c5ab770193a4def01ed1119f8" title="Prepare buffers for production of control token.">prepare_ctbuffers</a>(channel);
<a name="l01069"></a>01069     result = <a class="code" href="group__server.html#gafcca115990a649126f260767e365cde9" title="Auxiliary, low-level, negotiation function.">secure_channel_server_token</a>(channel,
<a name="l01070"></a>01070         &amp;channel-&gt;handle, 0, &amp;channel-&gt;itbuffer, &amp;channel-&gt;otbuffer);
<a name="l01071"></a>01071       <span class="comment">/* token produced. */</span>
<a name="l01072"></a>01072     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l01073"></a>01073     {
<a name="l01074"></a>01074         printf(<span class="stringliteral">&quot;Server: alert token produced.\n&quot;</span>);
<a name="l01075"></a>01075         <a class="code" href="group__callback.html#gaeeab3b47baab6f61ec95e9c987febf23" title="Forward locally produced token using registered callbacks.">accept_token</a>(channel);
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 }
<a name="l01078"></a>01078 
<a name="l01092"></a>01092 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__control.html#ga86a7ef6059569a958e57b958fd7e4ac8" title="Trigger TLS alert.">channel_alert</a>
<a name="l01093"></a><a class="code" href="group__control.html#ga86a7ef6059569a958e57b958fd7e4ac8">01093</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keywordtype">int</span> fatal, <span class="keywordtype">int</span> status )
<a name="l01094"></a>01094 {
<a name="l01095"></a>01095     SECURITY_STATUS result;
<a name="l01096"></a>01096     SCHANNEL_ALERT_TOKEN alert;
<a name="l01097"></a>01097     alert.dwTokenType   = SCHANNEL_ALERT;
<a name="l01098"></a>01098     alert.dwAlertType   = fatal? TLS1_ALERT_FATAL : TLS1_ALERT_WARNING;
<a name="l01099"></a>01099     alert.dwAlertNumber = status;
<a name="l01100"></a>01100     result = <a class="code" href="group__control.html#gaa7c46ce7b0f5eb39001b9b53bf9a46c6" title="Apply some control information to the secure channel state.">channel_apply</a>(channel, &amp;alert, <span class="keyword">sizeof</span>(alert));
<a name="l01101"></a>01101     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l01102"></a>01102     {
<a name="l01103"></a>01103         <span class="comment">//acquire_token_buffers(channel);</span>
<a name="l01104"></a>01104         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l01105"></a>01105             <a class="code" href="group__client.html#ga706a57e2c1a2539b25ef2057659d5262" title="Produce alert token.">secure_channel_client_token_5</a>(channel);
<a name="l01106"></a>01106         }
<a name="l01107"></a>01107         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l01108"></a>01108             <a class="code" href="group__server.html#ga20f74f12e34d72d158efa16a408d2a55" title="Produce alert token.">secure_channel_server_token_5</a>(channel);
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01122"></a>01122 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__exchange.html#ga9a92763e11717bffb7061e2f77944188" title="Encrypt chunk of stream as message.">secure_channel_encrypt</a>
<a name="l01123"></a><a class="code" href="group__exchange.html#ga9a92763e11717bffb7061e2f77944188">01123</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, PSecBufferDesc buffer )
<a name="l01124"></a>01124 {
<a name="l01125"></a>01125     SECURITY_STATUS result;
<a name="l01126"></a>01126     <span class="keywordflow">if</span> ( buffer-&gt;pBuffers[1].cbBuffer &lt;= 0 ) {
<a name="l01127"></a>01127         <span class="keywordflow">return</span>;
<a name="l01128"></a>01128     }
<a name="l01129"></a>01129     result = EncryptMessage(&amp;channel-&gt;handle, 0, buffer, 0);
<a name="l01130"></a>01130     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l01131"></a>01131     {
<a name="l01132"></a>01132         printf(<span class="stringliteral">&quot;%s, EncryptMessage(): 0x%08x\n&quot;</span>,
<a name="l01133"></a>01133             <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l01134"></a>01134         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l01135"></a>01135         channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l01136"></a>01136     }
<a name="l01137"></a>01137       <span class="comment">/* message encrypted, forward contents. */</span>
<a name="l01138"></a>01138     <span class="keywordflow">if</span> ( result == SEC_E_OK ) {
<a name="l01139"></a>01139         printf(<span class="stringliteral">&quot;%s, message encrypted.\n&quot;</span>, <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel));
<a name="l01140"></a>01140         <a class="code" href="group__callback.html#gaac353f1a6bc455b8108f6a0ed0dfbe29" title="Forward encrypted message content using registered callbacks.">accept_encrypted_message</a>(channel);
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142 }
<a name="l01143"></a>01143 
<a name="l01153"></a>01153 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__exchange.html#ga70b7387828f3a6e3f182dfab6320bac5" title="Attempt to decrypt message as chunk of stream.">secure_channel_decrypt</a>
<a name="l01154"></a><a class="code" href="group__exchange.html#ga70b7387828f3a6e3f182dfab6320bac5">01154</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, PSecBufferDesc buffer )
<a name="l01155"></a>01155 {
<a name="l01156"></a>01156     SECURITY_STATUS result;
<a name="l01157"></a>01157     <span class="keywordflow">if</span> ( buffer-&gt;pBuffers[0].cbBuffer &lt;= 0 ) {
<a name="l01158"></a>01158         <span class="keywordflow">return</span>;
<a name="l01159"></a>01159     }
<a name="l01160"></a>01160     result = DecryptMessage(&amp;channel-&gt;handle, buffer, 0, 0);
<a name="l01161"></a>01161     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l01162"></a>01162     {
<a name="l01163"></a>01163         <span class="keywordflow">if</span> ( result == SEC_E_INCOMPLETE_MESSAGE )
<a name="l01164"></a>01164         {
<a name="l01165"></a>01165             channel-&gt;<a class="code" href="structsecure__channel.html#a2d957ce9060f92b139708b991880e2fe" title="Set to 1 when the stream expects a secure_channel_push() call.">need_push</a> = 1;
<a name="l01166"></a>01166             channel-&gt;<a class="code" href="structsecure__channel.html#a3cfe83cb5e19209ccde6aa02dbab2127" title="Set to 1 when the stream expects a secure_channel_pull() call.">need_pull</a> = 0;
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( result != SEC_E_INCOMPLETE_MESSAGE )
<a name="l01169"></a>01169         {
<a name="l01170"></a>01170             printf(<span class="stringliteral">&quot;%s: DecryptMessage(): 0x%08x\n&quot;</span>,
<a name="l01171"></a>01171                 <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel), result);
<a name="l01172"></a>01172             channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_failed;
<a name="l01173"></a>01173             channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_fail;
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175     }
<a name="l01176"></a>01176       <span class="comment">/* peer has shutdown channel. */</span>
<a name="l01177"></a>01177     <span class="keywordflow">if</span> ( result == SEC_I_CONTEXT_EXPIRED )
<a name="l01178"></a>01178     {
<a name="l01179"></a>01179         printf(<span class="stringliteral">&quot;%s: peer requested shutdown.\n&quot;</span>, <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel));
<a name="l01180"></a>01180         <span class="comment">// Win2K bug: SEC_I_CONTEXT_EXPIRED might not be returned.</span>
<a name="l01181"></a>01181         <span class="comment">//            Check for decrypted data buffer of length 0.</span>
<a name="l01182"></a>01182           
<a name="l01183"></a>01183         <span class="comment">//release_stream_buffers(channel);</span>
<a name="l01184"></a>01184         <span class="comment">//release_token_buffers(channel);</span>
<a name="l01185"></a>01185         channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_expire;
<a name="l01186"></a>01186     }
<a name="l01187"></a>01187       <span class="comment">/* peer requested re-negotiation. */</span>
<a name="l01188"></a>01188     <span class="keywordflow">if</span> ( result == SEC_I_RENEGOTIATE )
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190         printf(<span class="stringliteral">&quot;%s: peer requested re-negotiation.\n&quot;</span>, <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel));
<a name="l01191"></a>01191         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#ad70a3bd738f7a065c85f372e5f383cbe" title="Set to 0 to deny renegotiation requests.">allow_renegotiation</a> )
<a name="l01192"></a>01192         {
<a name="l01193"></a>01193             printf(<span class="stringliteral">&quot;  -- proceeding.\n&quot;</span>);
<a name="l01194"></a>01194             channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_unsafe;
<a name="l01195"></a>01195             <a class="code" href="group__callback.html#ga3e65f7631eba9fecdc5080336adf98bc" title="Forward leftover message parts using registered callbacks.">accept_overflow</a>(channel);
<a name="l01196"></a>01196             <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server )
<a name="l01197"></a>01197             {
<a name="l01198"></a>01198                 <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l01199"></a>01199                 <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;itbuffer.pBuffers[0],
<a name="l01200"></a>01200                     channel-&gt;token_size,
<a name="l01201"></a>01201                     channel-&gt;dmbuffer.pBuffers[1].pvBuffer,
<a name="l01202"></a>01202                     channel-&gt;dmbuffer.pBuffers[1].cbBuffer);
<a name="l01203"></a>01203                 <a class="code" href="group__server.html#ga790f7a1074d2fadfdcff8d3ea988e51e" title="Produce additional neogitation tokens.">secure_channel_server_token_2</a>(channel);
<a name="l01204"></a>01204             }
<a name="l01205"></a>01205             <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client )
<a name="l01206"></a>01206             {
<a name="l01207"></a>01207                   <span class="comment">/* If the client requested re-negotiation, we&#39;ve been</span>
<a name="l01208"></a>01208 <span class="comment">                     decrypting pending messages while waiting for an OK from</span>
<a name="l01209"></a>01209 <span class="comment">                     the server.  Thus, we&#39;ve just received the server&#39;s reply</span>
<a name="l01210"></a>01210 <span class="comment">                     to the negotiation request; proceed! */</span>
<a name="l01211"></a>01211                 <span class="keywordflow">if</span> ( channel-&gt;requested_renegotiation )
<a name="l01212"></a>01212                 {
<a name="l01213"></a>01213                     <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l01214"></a>01214                     <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;itbuffer.pBuffers[0],
<a name="l01215"></a>01215                         channel-&gt;token_size,
<a name="l01216"></a>01216                         channel-&gt;dmbuffer.pBuffers[1].pvBuffer,
<a name="l01217"></a>01217                         channel-&gt;dmbuffer.pBuffers[1].cbBuffer);
<a name="l01218"></a>01218                     <a class="code" href="group__client.html#ga3193bc64f5319fd4904dbe88790f4258" title="Produce additional negotiation tokens.">secure_channel_client_token_2</a>(channel);
<a name="l01219"></a>01219                 }
<a name="l01220"></a>01220                 <span class="keywordflow">else</span> {
<a name="l01221"></a>01221                     <a class="code" href="group__client.html#ga69dbfe48bf1dddbefe8ea51609a00ee1" title="Produce re-negotiation token (different from REQUEST token).">secure_channel_client_token_4</a>(channel);
<a name="l01222"></a>01222                 }
<a name="l01223"></a>01223             }
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225         <span class="keywordflow">else</span>
<a name="l01226"></a>01226         {
<a name="l01227"></a>01227             printf(<span class="stringliteral">&quot;  -- rejecting.\n&quot;</span>);
<a name="l01228"></a>01228             <a class="code" href="group__control.html#ga86a7ef6059569a958e57b958fd7e4ac8" title="Trigger TLS alert.">channel_alert</a>(channel, 0, TLS1_ALERT_NO_RENEGOTIATION);
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231       <span class="comment">/* message decrypted. */</span>
<a name="l01232"></a>01232     <span class="keywordflow">if</span> ( result == SEC_E_OK ) {
<a name="l01233"></a>01233         printf(<span class="stringliteral">&quot;%s: Message decrypted.\n&quot;</span>, <a class="code" href="group__internal.html#gacaf9014997202eadf73fc2ecd162951c" title="String representation of secure_channel_role, for display.">channel_role</a>(channel));
<a name="l01234"></a>01234         <a class="code" href="group__callback.html#ga3e65f7631eba9fecdc5080336adf98bc" title="Forward leftover message parts using registered callbacks.">accept_overflow</a>(channel);
<a name="l01235"></a>01235         <a class="code" href="group__callback.html#ga643121c4a08ed7c10f5c9da527d4beda" title="Forward decrypted message content using registered callbacks.">accept_decrypted_message</a>(channel);
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237 }
<a name="l01238"></a>01238 
<a name="l01239"></a><a class="code" href="group__export.html#gac423b95890081cb58a1c0a7697b769bc">01239</a> <span class="keywordtype">void</span> <a class="code" href="group__export.html#gac423b95890081cb58a1c0a7697b769bc" title="Obtain information about the security package.">security_package_setup</a> ( <span class="keyword">struct</span> <a class="code" href="structsecurity__package.html" title="Information about the security service provider.">security_package</a> * package )
<a name="l01240"></a>01240 {
<a name="l01241"></a>01241     SECURITY_STATUS result;
<a name="l01242"></a>01242     PSecPkgInfoW description;
<a name="l01243"></a>01243     result = QuerySecurityPackageInfoW(<a class="code" href="group__internal.html#gafb880cf0a1b2f127bf32efeea9da4ebc" title="Security package name.">PACKAGE_NAME</a>, &amp;description);
<a name="l01244"></a>01244     <span class="keywordflow">if</span> ( FAILED(result) )
<a name="l01245"></a>01245     {
<a name="l01246"></a>01246         printf(<span class="stringliteral">&quot;QuerySecurityPackageInfo(): 0x%08x\n&quot;</span>, result);
<a name="l01247"></a>01247         <span class="keywordflow">return</span>;
<a name="l01248"></a>01248     }
<a name="l01249"></a>01249     package-&gt;<a class="code" href="structsecurity__package.html#a27fe3c0ed7fcf970e644b95dadb3a2fd" title="Maximum size of a negotiation token, in bytes.">token_size</a> = description-&gt;cbMaxToken;
<a name="l01250"></a>01250     FreeContextBuffer(description);
<a name="l01251"></a>01251 }
<a name="l01252"></a>01252 
<a name="l01253"></a><a class="code" href="group__export.html#ga8223665ac323e8f11051746b6d0e9961">01253</a> <span class="keywordtype">void</span> <a class="code" href="group__export.html#ga8223665ac323e8f11051746b6d0e9961" title="Clear channel state and set default settings.">secure_channel_clear</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01254"></a>01254 {
<a name="l01255"></a>01255     memset(channel, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a>));
<a name="l01256"></a>01256     channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> = secure_channel_virgin;
<a name="l01257"></a>01257     channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> = secure_channel_good;
<a name="l01258"></a>01258     channel-&gt;<a class="code" href="structsecure__channel.html#ad19ab3d159ca487c345d0a3d267bb035" title="Set to 0 to disable quick reconnect.">allow_reconnect</a>     = 1;
<a name="l01259"></a>01259     channel-&gt;<a class="code" href="structsecure__channel.html#ad70a3bd738f7a065c85f372e5f383cbe" title="Set to 0 to deny renegotiation requests.">allow_renegotiation</a> = 1;
<a name="l01260"></a>01260     channel-&gt;itbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l01261"></a>01261     channel-&gt;itbuffer.pBuffers = channel-&gt;buffers+0;
<a name="l01262"></a>01262     channel-&gt;itbuffer.cBuffers = 2;
<a name="l01263"></a>01263     channel-&gt;otbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l01264"></a>01264     channel-&gt;otbuffer.pBuffers = channel-&gt;buffers+2;
<a name="l01265"></a>01265     channel-&gt;otbuffer.cBuffers = 2;
<a name="l01266"></a>01266     channel-&gt;embuffer.ulVersion = SECBUFFER_VERSION;
<a name="l01267"></a>01267     channel-&gt;embuffer.pBuffers = channel-&gt;buffers+4;
<a name="l01268"></a>01268     channel-&gt;embuffer.cBuffers = 4;
<a name="l01269"></a>01269     channel-&gt;dmbuffer.ulVersion = SECBUFFER_VERSION;
<a name="l01270"></a>01270     channel-&gt;dmbuffer.pBuffers = channel-&gt;buffers+8;
<a name="l01271"></a>01271     channel-&gt;dmbuffer.cBuffers = 4;
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a><a class="code" href="group__export.html#ga4404ea372a26fa196694da73598ac67e">01274</a> <span class="keywordtype">void</span> <a class="code" href="group__export.html#ga4404ea372a26fa196694da73598ac67e" title="Finish initialization and start negotiation.">secure_channel_setup</a> ( <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsecurity__package.html" title="Information about the security service provider.">security_package</a> * package,
<a name="l01275"></a>01275     <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keyword">enum</span> secure_channel_role role )
<a name="l01276"></a>01276 {
<a name="l01277"></a>01277       <span class="comment">/* acquire credentials. */</span>
<a name="l01278"></a>01278     channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> = role;
<a name="l01279"></a>01279     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client )
<a name="l01280"></a>01280     {
<a name="l01281"></a>01281         <a class="code" href="group__client.html#gafe5e75b2c5433294bcf44d2bffa54341" title="Acquire security credentials.">secure_channel_client_setup</a>
<a name="l01282"></a>01282             (&amp;channel-&gt;<a class="code" href="structsecure__channel.html#ad879e1837e04ff5be64ce62df7254019" title="Host credentials (local peer, self).">credentials</a>, &amp;channel-&gt;<a class="code" href="structsecure__channel.html#ab3c7d2d510a61d97d7e1d07eeb31ece2" title="Host certificate (local peer, self).">certificate</a>);
<a name="l01283"></a>01283     }
<a name="l01284"></a>01284     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server )
<a name="l01285"></a>01285     {
<a name="l01286"></a>01286         <a class="code" href="group__server.html#ga9d8c7207a657f280fbc9c70d524be9b5" title="Acquire security credentials.">secure_channel_server_setup</a>
<a name="l01287"></a>01287             (&amp;channel-&gt;<a class="code" href="structsecure__channel.html#ad879e1837e04ff5be64ce62df7254019" title="Host credentials (local peer, self).">credentials</a>, &amp;channel-&gt;<a class="code" href="structsecure__channel.html#ab3c7d2d510a61d97d7e1d07eeb31ece2" title="Host certificate (local peer, self).">certificate</a>);
<a name="l01288"></a>01288     }
<a name="l01289"></a>01289       <span class="comment">/* allocate token buffers for negotiation. */</span>
<a name="l01290"></a>01290     channel-&gt;token_size = package-&gt;<a class="code" href="structsecurity__package.html#a27fe3c0ed7fcf970e644b95dadb3a2fd" title="Maximum size of a negotiation token, in bytes.">token_size</a>;
<a name="l01291"></a>01291     <a class="code" href="group__memory.html#gabc4146d0d1a080e91bba5f589c4f060d" title="Acquire memory used for buffering security tokens.">acquire_token_buffers</a>(channel);
<a name="l01292"></a>01292       <span class="comment">/* start negotiation. */</span>
<a name="l01293"></a>01293     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l01294"></a>01294         <a class="code" href="group__client.html#ga7aadb401915beb6f89f52a67c5de8b62" title="Produce initial negotiation token (&quot;ClientHello&quot;).">secure_channel_client_token_1</a>(channel);
<a name="l01295"></a>01295     }
<a name="l01296"></a>01296     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l01297"></a>01297         <a class="code" href="group__buffers.html#ga2636433a7cb1af21c62b558e77be76b6" title="Prepare get buffer for reception of negotiation token.">prepare_itbuffer</a>(channel);
<a name="l01298"></a>01298     }
<a name="l01299"></a>01299 }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301 <span class="keywordtype">size_t</span> <a class="code" href="group__export.html#ga79e5a600ef6e2d7ece454bced344a928" title="Buffer message data for encryption (at a later time).">secure_channel_push</a>
<a name="l01302"></a><a class="code" href="group__export.html#ga79e5a600ef6e2d7ece454bced344a928">01302</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keyword">const</span> <span class="keywordtype">char</span> * data, <span class="keywordtype">size_t</span> size )
<a name="l01303"></a>01303 {
<a name="l01304"></a>01304       <span class="comment">/* feed channel until engine blocks or all data is processed. */</span>
<a name="l01305"></a>01305     <span class="keywordtype">size_t</span> used = 0;
<a name="l01306"></a>01306     <span class="keywordflow">while</span> ((used &lt; size) &amp;&amp; (channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> == secure_channel_good))
<a name="l01307"></a>01307     {
<a name="l01308"></a>01308           <span class="comment">/* server starts negotiation in response to client token. */</span>
<a name="l01309"></a>01309         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> == secure_channel_virgin )
<a name="l01310"></a>01310         {
<a name="l01311"></a>01311             used += <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;itbuffer.pBuffers[0],
<a name="l01312"></a>01312                 channel-&gt;token_size, data+used, size-used);
<a name="l01313"></a>01313             <a class="code" href="group__server.html#gacbe602261078b49b52d126233f5acf39" title="Produce initial neogitation token (&quot;ServerHello&quot;).">secure_channel_server_token_1</a>(channel);
<a name="l01314"></a>01314         }
<a name="l01315"></a>01315            <span class="comment">/* negotiation isn&#39;t quite finished, keep processing tokens. */</span>
<a name="l01316"></a>01316         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> == secure_channel_unsafe )
<a name="l01317"></a>01317         {
<a name="l01318"></a>01318             used += <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;itbuffer.pBuffers[0],
<a name="l01319"></a>01319                 channel-&gt;token_size, data+used, size-used);
<a name="l01320"></a>01320             <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l01321"></a>01321                 <a class="code" href="group__client.html#ga3193bc64f5319fd4904dbe88790f4258" title="Produce additional negotiation tokens.">secure_channel_client_token_2</a>(channel);
<a name="l01322"></a>01322             }
<a name="l01323"></a>01323             <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l01324"></a>01324                 <a class="code" href="group__server.html#ga790f7a1074d2fadfdcff8d3ea988e51e" title="Produce additional neogitation tokens.">secure_channel_server_token_2</a>(channel);
<a name="l01325"></a>01325             }
<a name="l01326"></a>01326         }
<a name="l01327"></a>01327           <span class="comment">/* session has been secured, encrypt data! */</span>
<a name="l01328"></a>01328         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> == secure_channel_secure )
<a name="l01329"></a>01329         {
<a name="l01330"></a>01330               <span class="comment">/* prepare data only, wait for manual flush. */</span>
<a name="l01331"></a>01331             used += <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;embuffer.pBuffers[1],
<a name="l01332"></a>01332                 channel-&gt;stream_size, data+used, size-used);
<a name="l01333"></a>01333         }
<a name="l01334"></a>01334     }
<a name="l01335"></a>01335     <span class="keywordflow">return</span> (used);
<a name="l01336"></a>01336 }
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="keywordtype">size_t</span> <a class="code" href="group__export.html#gaaa5f1890648adbb4398236c28f6098bc" title="Attempt to message decryption.">secure_channel_pull</a>
<a name="l01339"></a><a class="code" href="group__export.html#gaaa5f1890648adbb4398236c28f6098bc">01339</a>     ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel, <span class="keyword">const</span> <span class="keywordtype">char</span> * data, <span class="keywordtype">size_t</span> size )
<a name="l01340"></a>01340 {
<a name="l01341"></a>01341       <span class="comment">/* feed channel until engine blocks or all data is processed. */</span>
<a name="l01342"></a>01342     <span class="keywordtype">size_t</span> used = 0;
<a name="l01343"></a>01343     <span class="keywordflow">while</span> ((used &lt; size) &amp;&amp; (channel-&gt;<a class="code" href="structsecure__channel.html#a751f065a3802d13ce177a14352f328a8" title="Current channel error state.">error</a> == secure_channel_good))
<a name="l01344"></a>01344     {
<a name="l01345"></a>01345           <span class="comment">/* server starts negotiation in response to client token. */</span>
<a name="l01346"></a>01346         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> == secure_channel_virgin )
<a name="l01347"></a>01347         {
<a name="l01348"></a>01348             used += <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;itbuffer.pBuffers[0],
<a name="l01349"></a>01349                 channel-&gt;token_size, data+used, size-used);
<a name="l01350"></a>01350             <a class="code" href="group__server.html#gacbe602261078b49b52d126233f5acf39" title="Produce initial neogitation token (&quot;ServerHello&quot;).">secure_channel_server_token_1</a>(channel);
<a name="l01351"></a>01351         }
<a name="l01352"></a>01352            <span class="comment">/* negotiation isn&#39;t quite finished, keep processing tokens. */</span>
<a name="l01353"></a>01353         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> == secure_channel_unsafe )
<a name="l01354"></a>01354         {
<a name="l01355"></a>01355             used += <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;itbuffer.pBuffers[0],
<a name="l01356"></a>01356                 channel-&gt;token_size, data+used, size-used);
<a name="l01357"></a>01357             <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l01358"></a>01358                 <a class="code" href="group__client.html#ga3193bc64f5319fd4904dbe88790f4258" title="Produce additional negotiation tokens.">secure_channel_client_token_2</a>(channel);
<a name="l01359"></a>01359             }
<a name="l01360"></a>01360             <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l01361"></a>01361                 <a class="code" href="group__server.html#ga790f7a1074d2fadfdcff8d3ea988e51e" title="Produce additional neogitation tokens.">secure_channel_server_token_2</a>(channel);
<a name="l01362"></a>01362             }
<a name="l01363"></a>01363         }
<a name="l01364"></a>01364           <span class="comment">/* can&#39;t decrypt data until channel is secured. */</span>
<a name="l01365"></a>01365         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a5b13009bc1dbe9fea3dd10e732cef4fd" title="Current channel state.">state</a> == secure_channel_secure )
<a name="l01366"></a>01366         {
<a name="l01367"></a>01367               <span class="comment">/* prepare data for decryption. */</span>
<a name="l01368"></a>01368             used += <a class="code" href="group__internal.html#ga0da8d7ae39263c8ce44cf8ea62f23e36" title="Copy data into security buffer.">channel_copy</a>(&amp;channel-&gt;dmbuffer.pBuffers[0],
<a name="l01369"></a>01369                 channel-&gt;stream_size, data+used, size-used);
<a name="l01370"></a>01370               <span class="comment">/* attempt to decrypt message. */</span>
<a name="l01371"></a>01371             <a class="code" href="group__exchange.html#ga70b7387828f3a6e3f182dfab6320bac5" title="Attempt to decrypt message as chunk of stream.">secure_channel_decrypt</a>(channel, &amp;channel-&gt;dmbuffer);
<a name="l01372"></a>01372         }
<a name="l01373"></a>01373     }
<a name="l01374"></a>01374     <span class="keywordflow">return</span> (used);
<a name="l01375"></a>01375 }
<a name="l01376"></a>01376 
<a name="l01377"></a><a class="code" href="group__export.html#gac35a8b6a4649efd48b35fd32261e4270">01377</a> <span class="keywordtype">void</span> <a class="code" href="group__export.html#gac35a8b6a4649efd48b35fd32261e4270" title="Force any buffered data to be output.">secure_channel_flush</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01378"></a>01378 {
<a name="l01379"></a>01379     <a class="code" href="group__exchange.html#ga9a92763e11717bffb7061e2f77944188" title="Encrypt chunk of stream as message.">secure_channel_encrypt</a>(channel, &amp;channel-&gt;embuffer);
<a name="l01380"></a>01380 }
<a name="l01381"></a>01381 
<a name="l01382"></a><a class="code" href="group__export.html#ga7fae4c71a62d57e0a737ed7073d2255c">01382</a> <span class="keywordtype">void</span> <a class="code" href="group__export.html#ga7fae4c71a62d57e0a737ed7073d2255c" title="Notify peer of intent to re-negotiate.">secure_channel_renegotiate</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01383"></a>01383 {
<a name="l01384"></a>01384     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l01385"></a>01385         <a class="code" href="group__client.html#ga0c4c58fa2becde4119eec419baf01e97" title="Produce re-negotiation REQUEST token.">secure_channel_client_token_0</a>(channel);
<a name="l01386"></a>01386     }
<a name="l01387"></a>01387     <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l01388"></a>01388         <a class="code" href="group__server.html#ga20d1d34ccf686a76514fc8c881838771" title="Produce re-negotiation request token.">secure_channel_server_token_0</a>(channel);
<a name="l01389"></a>01389     }
<a name="l01390"></a>01390 }
<a name="l01391"></a>01391 
<a name="l01392"></a><a class="code" href="group__export.html#ga89f33568a90886c68898fe3a226b6ef3">01392</a> <span class="keywordtype">void</span> <a class="code" href="group__export.html#ga89f33568a90886c68898fe3a226b6ef3" title="Initiate shutdown.">secure_channel_close</a> ( <span class="keyword">struct</span> <a class="code" href="structsecure__channel.html" title="High-level wrapper for the security channel interface.">secure_channel</a> * channel )
<a name="l01393"></a>01393 {
<a name="l01394"></a>01394     SECURITY_STATUS result;
<a name="l01395"></a>01395     DWORD token = SCHANNEL_SHUTDOWN;
<a name="l01396"></a>01396     result = <a class="code" href="group__control.html#gaa7c46ce7b0f5eb39001b9b53bf9a46c6" title="Apply some control information to the secure channel state.">channel_apply</a>(channel, &amp;token, <span class="keyword">sizeof</span>(token));
<a name="l01397"></a>01397       <span class="comment">/* token queued internally. */</span>
<a name="l01398"></a>01398     <span class="keywordflow">if</span> ( result == SEC_E_OK )
<a name="l01399"></a>01399     {
<a name="l01400"></a>01400           <span class="comment">/* extract token. */</span>
<a name="l01401"></a>01401         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_client ) {
<a name="l01402"></a>01402             <a class="code" href="group__client.html#ga736e518421cdb1aedcccf2eef101924e" title="Produce shutdown notification token.">secure_channel_client_token_3</a>(channel);
<a name="l01403"></a>01403         }
<a name="l01404"></a>01404         <span class="keywordflow">if</span> ( channel-&gt;<a class="code" href="structsecure__channel.html#a0ce30de7d22abd82b201ede3a6001373" title="Channel role.">role</a> == secure_channel_server ) {
<a name="l01405"></a>01405             <a class="code" href="group__server.html#ga920a577bb040e1df2fe15fa4a120e980" title="Produce shutdown notification token.">secure_channel_server_token_3</a>(channel);
<a name="l01406"></a>01406         }
<a name="l01407"></a>01407     }
<a name="l01408"></a>01408 }
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>cschannel.c</b>      </li>
      <li class="footer">Generated on Wed Aug 10 2011 23:20:36 for cschannel by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
